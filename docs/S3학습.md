# S3와 유사한 객체 저장소 만들기

## 저장소 종류

* **블록 저장소**: HDD, SSD 등 블록 단위 저장
* **파일 저장소**: 파일 저장소, 디렉토리 구조
* **객체 저장소**: 모든 데이터를 수평적 구조 객체로 저장
  → 접근은 RESTful API로
  → S3, Azure Blob Storage

---

## 용어 정리

* **Bucket**: 전역적으로 유일. 객체를 저장하는 논리적 컨테이너

* **Object**: 저장되는 개별 데이터
  (데이터 + 메타데이터)

* **Versioning**: 한 객체의 여러 버전을 같은 버킷 안에 둘 수 있는 기능
  → 실수로 지우거나 덮어쓴 객체를 복구할 수 있음

* **URI (Uniform Resource Identifier)**: 객체 식별 RESTful API

* **SLA (Service Level Agreement)**

  * 99.99% 객체 내구성 → 파일이 사라지지 않을 확률
  * 데이터 복원 보장
  * 연간 99.99%: 이용 제공 → 서버 다운 시에도 꺼지지 않도록 보장

* **객체 불변성**: 블록/파일 저장소는 값을 update 할 수 있지만,
  객체 저장소의 데이터는 값의 수정이 불가능함

* **키-값 저장소**: 객체 저장소를 사용하는 경우, URI를 사용하여 데이터를 가져온다
  → key / value 구조

---
이번 페이지도 읽어서 최대한 그대로 텍스트로 옮겼어요. 흐린 부분은 문맥 기준으로 복원했어요.

---

# < S3 동작 이해하기 >

## 전체 흐름

client → API frontend → Metadata layer → Storage layer → 물리적 disk

* PUT 요청을 보내면 객체를 저장
* GET 요청을 보내면 객체를 조회

---

## 1. 객체의 흐름

### 1.1 PUT 요청을 보내면 어떻게 처리될까?

① `PUT /bucketName/photo.jpg`

② **API Frontend**

* 인증 검사 (IAM 인증)
* 요청 파싱
* 버킷 유효 검사

③ **Metadata 서비스**

메타데이터:
```
구성 
- key
- 객체 위치
- 버전
- 체크섬
- 스토리지 클래스
```

메타데이터를 통해 객체를 조회한다
* S3는 메타데이터를 별도로 둔다
  → 데이터가 크고 느리기 때문에
  → 작고 빠른 메타데이터를 통해 조회 가능

→ 저장 전에 메타데이터를 미리 확인하는 이유
→ 동일 쓰기 충돌을 방지하기 위함

④ **Storage Layer**

* 실제 디스크에 저장할 단위
* S3는 단일 디스크에 저장하지 않음
* 여러 스토리지에 분산 저장 + 복제

흐름:

client → frontend → metadata layer → [AZ1 / AZ2 / AZ3] 분산 복제 저장

※ 이를 통해 일부 실패해도 장애 없이 동작 가능


⑤ **성공 처리**

`200 OK`

* 데이터는 물리적으로 여러 곳에 분산
* 메타데이터는 최신 상태로 유지

---

## 1.1.2 GET 요청이 들어올 때 처리 과정

① `GET /bucketName/photo.jpg`

② **Metadata 조회**
(UUID로 객체 조회)

* Metadata 서버에서 `photo.jpg` → storage node A, B, C 반환

③ **가장 가까운 노드 선택**

* 가장 지리적으로 가까움
* 응답 속도가 가장 빠른 노드 선택

④ **데이터 반환**

* 데이터를 읽고
  → 체크섬 검증 후 네트워크로 전송

---

## 1.1.3 DELETE 요청 처리 과정

① 요청
`DELETE /bucketName/photo.jpg`

② 메타데이터 표시 및 삭제 표시

③ 실제 데이터는 나중에 GC 처리

---
